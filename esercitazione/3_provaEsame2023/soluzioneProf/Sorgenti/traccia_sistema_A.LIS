00008000                                     1     ORG $8000
00008000                                     2  
00008000                                     3  ***************  Definizione di macro
00008000  =00000001                          4  IS_REC_C   EQU 1     *  Valore della variabile Possesso quando si sta ricevendo da C
00008000  =00000000                          5  IS_REC_B   EQU 0     *  Valore della variabile Possesso quando si sta ricevendo da B 
00008000  =FFFFFFFF                          6  IS_REC_NONE EQU -1 * Valore della variabile di possesso quando non si sta ricevendo da nessuno
00008000                                     7  
00008000  =00000003                          8  MEX_CHAR	EQU 3     *  Numero di caratteri che compongono un messaggio
00008000  =00000005                          9  N_ITER	EQU 5	   *  Numero di iterazioni di esecuzione 
00008000  =00000002                         10  N_MEX_B_ITER  EQU 2 * Numero di messaggi attesi da B in una iterazione (un messaggio � composto da MEX_CHAR caratteri)
00008000  =00000003                         11  N_MEX_PER_ITER EQU 3 * Numero di messaggi per iterazione
00008000                                    12  
00008000                                    13  * Registri di controllo della PIA.
00008000  =00002004                         14  PIADA	EQU    $2004	
00008000  =00002005                         15  PIACA	EQU    $2005	
00008000  =00002008                         16  PIADA2	EQU	$2008
00008000  =00002009                         17  PIACA2	EQU	$2009
00008000                                    18  
00008000                                    19  ***************** Definizioni di variabili
00008000                                    20  RCV_BUFFER 		DS.B  64  		* La dimensione del messaggio viene data dal prodotto di  Numero It* Numero Mex per It * Caratteri per messaggio ( 3 * 3 * 3 = 27) 
00008040  0000                              21  LOCK            		DC.W 0 		* Variabile utilizzata per l'accesso alla sezione critica mediante TAS
00008042  FFFF                              22  POSSESSO  		DC.W IS_REC_NONE  * Variabile ternaria che indica il dispositivo da cui si sta attualmente ricevendo
00008044  0000                              23  CTR_CHAR   		DC.W 0	* Contatore di caratteri ricevuti da una periferica, utilizzato per verificare la completezza di un messaggio
00008046  0000                              24  TOTAL_CH_RCVD 	DC.W 0	* Contatore del numero totale di bytes ricevuti.
00008048  0000                              25  CTR_MEX_B 		DC.W 0 	* Contatore dei messaggi ricevuti da B durante una iterazione
0000804A  0000                              26  END_B         		DC.W 0	* Variabile che indica che il sistema da B ha terminato la ricezione dei messaggi in una iterazione. 
0000804C  0000                              27  END_C         		DC.W 0       	* Variabile che indica che il sistema da C ha terminato la ricezione dei messaggi in una iterazione.
0000804E  0000                              28  K                  		DC.W 0       	* Contatore delle iterazioni.
00008050                                    29  
00008050                                    30  
00008050                                    31  
00008200                                    32  	ORG	$8200
00008200                                    33  
00008200  4EB9 0000822C                     34  INIT	JSR	INIZIALIZZA
00008206                                    35  
00008206  40C1                              36  	MOVE.W	SR,D1
00008208  0241 D8FF                         37  	ANDI.W	#$D8FF,D1
0000820C  46C1                              38  	MOVE.W	D1,SR
0000820E                                    39  
0000820E                                    40  
0000820E  3A39 0000804A                     41  LOOP		MOVE.W END_B,D5
00008214  3C39 0000804C                     42  		MOVE.W END_C,D6
0000821A  3E39 0000804E                     43  		MOVE.W K,D7
00008220  3839 00008042                     44  		MOVE.W POSSESSO,D4
00008226  4EF9 0000820E                     45  		JMP	LOOP
0000822C                                    46  
0000822C                                    47  
0000822C                                    48  
0000822C                                    49  INIZIALIZZA
0000822C  11FC 0000 2005                    50  	MOVE.B	#0,PIACA
00008232  11FC 0000 2004                    51  	MOVE.B	#0,PIADA
00008238  11FC 0025 2005                    52  	MOVE.B	#%00100101,PIACA
0000823E  11FC 0000 2009                    53  	MOVE.B	#0,PIACA2
00008244  11FC 0000 2008                    54  	MOVE.B	#0,PIADA2
0000824A  11FC 0025 2009                    55  	MOVE.B	#%00100101,PIACA2
00008250  4E75                              56  	RTS
00008252                                    57  
00008700                                    58       ORG $8700
00008700                                    59  ******** Inizio ISR con sezione critica.
00008700  4AF9 00008040                     60  IB     	 		TAS LOCK 		* Per prima cosa prova ad ottenere il lock
00008706  6600 01F6                         61  	 		BNE IB_RTE		* Se non lo si ottiene si esce
0000870A  0C79 0001 0000804A                62  	 		CMP.W #1,END_B 	* Se C ha terminato rilascia il lock senza aggiornare la variabile di possesso
00008712  6700 0016                         63  	 		BEQ IB_REL_LOCK	
00008716  0C79 0001 00008042                64  IB_CK_OWN		CMP.W  #IS_REC_C,POSSESSO * Se possesso = is_reading_C allora rilascia il lock, senza aggiornare la variabile di possesso
0000871E  6700 000A                         65  	     		BEQ IB_REL_LOCK
00008722                                    66  ******* Fine della sezione critica
00008722  33FC 0000 00008042                67  			MOVE.W #IS_REC_B,POSSESSO * Da questo momento in poi la ricezione avviene da B
0000872A  33FC 0000 00008040                68  IB_REL_LOCK		MOVE.W #0,LOCK * Posso rilasciare il Lock
00008732                                    69  
00008732                                    70  ********  Controllo per lo switch case
00008732                                    71  			* A questo punto bisogna distinguere le differenti casistiche a seconda del valore della variabile possesso.
00008732                                    72  			* Qui eseguo il salvataggio del contesto
00008732  48E7 E080                         73  			MOVEM.L D0-D2/A0,-(SP)
00008736                                    74  			
00008736  0C79 FFFF 00008042                75  			CMP.W #IS_REC_NONE,POSSESSO
0000873E  6700 00AE                         76  			BEQ IB_EX_RN * I vari casi sono indicati come ISRB_ Execution_Receiving"Type", in questo caso RN perch� possesso � "is_rec_none"
00008742  0C79 0001 00008042                77  			CMP.W  #IS_REC_C,POSSESSO
0000874A  6700 00EA                         78  			BEQ IB_EX_RC
0000874E                                    79  
0000874E                                    80  ****** Casistica in cui la ISR deve leggere il messaggio in quanto � suo il possesso.	
0000874E  3039 00008046                     81  IB_EX_RB		MOVE.W TOTAL_CH_RCVD,D0
00008754  3239 00008044                     82  			MOVE.W CTR_CHAR,D1
0000875A  207C 00008000                     83  			MOVEA.L #RCV_BUFFER,A0
00008760  11B8 2004 0000                    84  			MOVE.B PIADA,(A0,D0) * Salva il carattere
00008766  5240                              85  			ADD.W #1,D0                   		* Incrementa di 1 il numero di caratteri TOTALI RICEVUTI
00008768  33C0 00008046                     86  			MOVE.W D0,TOTAL_CH_RCVD	* Aggiorna la var in memoria
0000876E  5241                              87  			ADD.W #1,D1                   		* Incrementa di 1 il numero di caratteri del messaggio corrente
00008770  33C1 00008044                     88  			MOVE.W D1,CTR_CHAR		* Aggiorna la variabile in memoria
00008776                                    89  			***  Controlli messaggio completo
00008776  B27C 0003                         90  			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
0000877A  6600 017E                         91  			BNE IB_REG_REST		* Se non � completo allora salta alla fine
0000877E  33FC 0000 00008044                92  			MOVE.W #0,CTR_CHAR 	* Se invece il numero di messaggi � completo, resetta il numero di caratteri del messaggio attuale
00008786  33FC FFFF 00008042                93  			MOVE.W #IS_REC_NONE,POSSESSO * La variabile possesso va resettata in quanto B non la possiede pi�.
0000878E  3239 00008048                     94  			MOVE.W CTR_MEX_B,D1	* Salva il conteggio attuale dei messaggi ricevuti da B (durante una iterazione)
00008794  5241                              95  			ADDI.W  #1,D1		
00008796  33C1 00008048                     96  			MOVE.W D1,CTR_MEX_B	* Incrementa di 1 il numero di messaggi ricevuti da B nell'iterazione corrente
0000879C  B27C 0002                         97  			CMP.W  #N_MEX_B_PER_ITER,D1 *Verifica se B non abbia completato il numero di messaggi da ricevere in una iterazione
000087A0  6600 004C                         98  			BNE	  IB_EX_RN * Se non li ha completati, rimane solo da verificare se C ha un messaggio sospeso e pu� leggere, questo coincide con la casistica IB_EX_RN
000087A4                                    99  			* Se invece li ha completati, allora si aggiorna END_B e si verifica che anche C non abbia finito
000087A4  33FC 0001 0000804A               100  			MOVE.W #1,END_B
000087AC  0C79 0001 0000804C               101  			CMP.W #1,END_C * Controllo se end_C == 1
000087B4  6600 0044                        102  			BNE IB_RN_CS * Anche in questo caso, se non sono uguali, allora salto alla verifica di C (non � necessario verificare che END_C sia diverso da 1, quindi salto alla label immediatamente successiva)
000087B8                                   103  			* Verifico che END_B ed END_C siano identici.
000087B8  3439 0000804E                    104  			MOVE.W K,D2
000087BE  5242                             105  			ADDI.W #1,D2
000087C0  33C2 0000804E                    106  			MOVE.W D2,K * Incrementa il numero di iterazioni
000087C6  B47C 0005                        107  			CMP.W #N_ITER,D2 * Se � uguale allora salta alla fine( lasciando end_B ed end_C pari ad 1)
000087CA  6700 012E                        108  			BEQ IB_REG_REST
000087CE  33FC 0000 0000804A               109  			MOVE.W #0,END_B * Altrimenti, resetta le variabili di conteggio il valore degli end e controlla solo se C sia sospeso
000087D6  33FC 0000 0000804C               110  			MOVE.W #0,END_C
000087DE  33FC 0000 00008048               111  			MOVE.W #0,CTR_MEX_B 
000087E6  6000 0012                        112  			BRA IB_RN_CS 	* Salta al controllo della sospensione
000087EA  6000 010E                        113  			BRA IB_REG_REST * Il codice non dovrebbe mai arrivare qui,
000087EE                                   114  
000087EE                                   115  ****** Casistica in cui non stava leggendo nessuno
000087EE  0C79 0001 0000804C               116  IB_EX_RN		CMP.W #1,END_C	* Controlla se C non ha terminato i caratteri durante la sua iterazione.
000087F6  6700 0102                        117  		           	BEQ IB_REG_REST
000087FA                                   118  * Nota: 	IB_Receiving None, Check Suspended ( � una sottolabel di IB_EX_RN)
000087FA                                   119  * 		Questa sottolabel � definita per convenienza, in quanto molti sottobranch terminano con un controllo dello stato di sospesione di C.
000087FA  1038 2009                        120  IB_RN_CS		MOVE.B PIACA2,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
000087FE  0200 0080                        121  			ANDI.B  #$80,D0
00008802  6700 00F6                        122  			BEQ  IB_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
00008806                                   123  			* Altrimenti aggiorna lo stato della variabile di possesso
00008806  33FC 0001 00008042               124  			MOVE.W #IS_REC_C,POSSESSO * Scrivi chi sta leggendo
0000880E  3039 00008046                    125  			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
00008814  3200                             126  			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
00008816  5241                             127  			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
00008818  33C1 00008046                    128  			MOVE.W D1,TOTAL_CH_RCVD
0000881E                                   129  			* Quello che stiamo ricevendo � SICURAMENTE il primo carattere di C, quindi, invece di incrementare, andiamo direttamente a scrivere uno in memoria.
0000881E  33FC 0001 00008044               130  			MOVE.W #1,CTR_CHAR
00008826                                   131  			* Lettura del carattere
00008826  207C 00008000                    132  			MOVEA.L #RCV_BUFFER,A0
0000882C  11B8 2008 0000                   133  			MOVE.B PIADA2,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
00008832  6000 00C6                        134  			BRA IB_REG_REST
00008836                                   135  
00008836                                   136  ****** Casistica in cui stava leggendo altra periferica
00008836                                   137  			* Qui non � necessario verificare che END_C sia uguale ad 1 ( possesso = is_reading_C, quindi sicuramente END_C � diverso da 1)
00008836  1038 2009                        138  IB_EX_RC		MOVE.B PIACA2,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
0000883A  0200 0080                        139  			ANDI.B  #$80,D0
0000883E  6700 00BA                        140  			BEQ  IB_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
00008842  3039 00008046                    141  			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
00008848  3200                             142  			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
0000884A  5241                             143  			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
0000884C  33C1 00008046                    144  			MOVE.W D1,TOTAL_CH_RCVD
00008852  3239 00008044                    145  			MOVE.W CTR_CHAR,D1 * Qui aggiorno il contatore dei caratteri correnti, nota che dato che il possesso non era is_rec_C allora avrei potuto direttamente inserire #1 in ctr_char
00008858  5241                             146  			ADDI.W #1,D1 
0000885A  33C1 00008044                    147  			MOVE.W D1,CTR_CHAR
00008860                                   148  			**** IMPORTANTE: Differentemente dal caso 2: qui � necessario svolgere tutte le operazioni che C avrebbe svolto, non � possibile infatti fare assunzioni sul numero di messaggi gi� ricevuti
00008860  B27C 0003                        149  			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
00008864  6600 0088                        150  			BNE IB_RC_END		* Se non � completo allora si legge il carattere di C e si esce
00008868  33FC 0001 0000804C               151  			MOVE.W #1,END_C 		* Se invece il messaggio � completo, si pone END_C ad 1
00008870                                   152  			* In ogni caso si resetta la variabile possesso
00008870  33FC FFFF 00008042               153  			MOVE.W #IS_REC_NONE,POSSESSO
00008878  33FC 0000 00008044               154  			MOVE.W #0,CTR_CHAR * Si resetta il numero di caratteri correnti
00008880                                   155  			* Si verifica se anche B ha finito	
00008880  0C79 0001 0000804A               156  			CMP.W #1,END_B
00008888                                   157  			* in Questo caso, se B non ha terminato, procedo  a leggere il carattere di B (e poi seguentemente quello di C).
00008888  6600 0034                        158  			BNE IB_RC_UP_IT
0000888C  3239 0000804E                    159  			MOVE.W K,D1
00008892  5241                             160  			ADDI.W   #1,D1
00008894  33C1 0000804E                    161  			MOVE.W D1,K
0000889A  0C79 0005 0000804E               162  			CMP.W  #N_ITER,K
000088A2  6700 004A                        163  			BEQ   IB_RC_END * Se ho raggiunto il numero massimo di iterazioni allora esco ( leggendo prima il carattere di C sempre)
000088A6                                   164  			* Altrimenti resetta le variabili, leggi il carattere di B e poi leggi il carattere che C avrebbe dovuto ricevere
000088A6  33FC 0000 0000804A               165  			MOVE.W #0,END_B
000088AE  33FC 0000 0000804C               166  			MOVE.W #0,END_C
000088B6  33FC 0000 00008048               167  			MOVE.W #0,CTR_MEX_B
000088BE                                   168  
000088BE  33FC 0000 00008042               169  IB_RC_UP_IT		MOVE.W #IS_REC_B,POSSESSO
000088C6  3239 00008046                    170  			MOVE.W TOTAL_CH_RCVD,D1
000088CC  3439 00008044                    171  			MOVE.W CTR_CHAR,D2
000088D2  207C 00008000                    172  			MOVEA.L #RCV_BUFFER,A0
000088D8  11B8 2004 1000                   173  			MOVE.B  PIADA,(A0,D1)
000088DE  5242                             174  			ADDI.W #1,D2
000088E0  33C2 00008044                    175  			MOVE.W D2,CTR_CHAR
000088E6  5241                             176  			ADDI.W #1,D1
000088E8  33C1 00008046                    177  			MOVE.W D1,TOTAL_CH_RCVD
000088EE                                   178  
000088EE                                   179  			* Come nel caso precedente, la lettura avviene alla fine dopo aggiornamento delle variabili di stato.
000088EE  207C 00008000                    180  IB_RC_END		MOVEA.L #RCV_BUFFER,A0
000088F4  11B8 2008 0000                   181  			MOVE.B PIADA2,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
000088FA                                   182  
000088FA                                   183  			
000088FA  4CDF 0107                        184  IB_REG_REST		MOVEM.L (SP)+,D0-D2/A0
000088FE  4E73                             185  IB_RTE      		RTE
00008900                                   186  
00008900                                   187  
00008900                                   188  
00008900                                   189  
00008900                                   190   		ORG $8900
00008900                                   191  ******** Inizio ISR con sezione critica.
00008900  4AF9 00008040                    192  IC     	 		TAS LOCK 		* Per prima cosa prova ad ottenere il lock
00008906  6600 0202                        193  	 		BNE IC_RTE		* Se non lo si ottiene si esce
0000890A  0C79 0001 0000804C               194  	 		CMP.W #1,END_C 	* Se C ha terminato rilascia il lock senza aggiornare la variabile di possesso
00008912  6700 0016                        195  	 		BEQ IC_REL_LOCK	
00008916  0C79 0000 00008042               196  IC_CK_OWN		CMP.W  #IS_REC_B,POSSESSO * Se possesso = is_reading_B allora rilascia il lock, senza aggiornare la variabile di possesso
0000891E  6700 000A                        197  	     		BEQ IC_REL_LOCK
00008922                                   198  ******* Fine della sezione critica
00008922  33FC 0001 00008042               199  			MOVE.W #IS_REC_C,POSSESSO * Da questo momento in poi la ricezione avviene da C
0000892A  33FC 0000 00008040               200  IC_REL_LOCK		MOVE.W #0,LOCK * Posso rilasciare il Lock
00008932                                   201  
00008932                                   202  ******** Controllo per lo switch case
00008932                                   203  			* A questo punto bisogna distinguere le differenti casistiche a seconda del valore della variabile possesso.
00008932                                   204  			* Qui eseguo il salvataggio del contesto
00008932  48E7 E080                        205  			MOVEM.L D0-D2/A0,-(SP)
00008936                                   206  
00008936                                   207  			* Questa sequenza di CMP simula lo switch case presente nello pseudo-codice.
00008936  0C79 FFFF 00008042               208  			CMP.W #IS_REC_NONE,POSSESSO
0000893E  6700 0098                        209  			BEQ IC_EX_RN 
00008942  0C79 0000 00008042               210  			CMP.W  #IS_REC_B,POSSESSO
0000894A  6700 00D4                        211  			BEQ IC_EX_RB
0000894E                                   212  
0000894E                                   213  ****** Casistica in cui la ISR deve leggere il messaggio in quanto � suo il possesso.	
0000894E  3039 00008046                    214  IC_EX_RC		MOVE.W TOTAL_CH_RCVD,D0 	
00008954  3239 00008044                    215  			MOVE.W CTR_CHAR,D1		
0000895A  207C 00008000                    216  			MOVEA.L #RCV_BUFFER,A0
00008960  11B8 2008 0000                   217  			MOVE.B PIADA2,(A0,D0) * Salva il carattere
00008966  5240                             218  			ADDI.W #1,D0                   		* Incrementa di 1 il numero di caratteri TOTALI RICEVUTI
00008968  33C0 00008046                    219  			MOVE.W D0,TOTAL_CH_RCVD	* Aggiorna la var in memoria
0000896E  5241                             220  			ADDI.W #1,D1                   		* Incrementa di 1 il numero di caratteri del messaggio corrente
00008970  33C1 00008044                    221  			MOVE.W D1,CTR_CHAR		* Aggiorna la variabile in memoria
00008976                                   222  			***  Controlli messaggio completo
00008976  B27C 0003                        223  			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
0000897A  6600 018A                        224  			BNE IC_REG_REST		* Se non � completo allora salta alla fine
0000897E  33FC 0000 00008044               225  			MOVE.W #0,CTR_CHAR 	* Se invece il numero di messaggi � completo, resetta il numero di caratteri del messaggio attuale
00008986  33FC 0001 0000804C               226  			MOVE.W #1,END_C		* Indica che C ha finito
0000898E  33FC FFFF 00008042               227  			MOVE.W #IS_REC_NONE,POSSESSO * La variabile possesso va resettata in quanto C non la possiede pi�.
00008996  0C79 0001 0000804A               228  			CMP.W #1,END_B * Controllo se end_B == 1
0000899E  6600 0044                        229  			BNE IC_RN_BS * Se B non ha concluso ( end_B != 1) allora devo solo recuperare un carattere di B ( senza nuovamente verificare se end_B == 1)
000089A2  3439 0000804E                    230  			MOVE.W K,D2 * Altrimenti devo incrementare il numero di iterazioni.
000089A8  5242                             231  			ADDI.W #1,D2
000089AA  33C2 0000804E                    232  			MOVE.W D2,K * Incrementa il numero di iterazioni
000089B0  B47C 0005                        233  			CMP.W #N_ITER,D2 * Se � uguale allora salta alla fine( lasciando end_B ed end_C pari ad 1)
000089B4  6700 0150                        234  			BEQ IC_REG_REST
000089B8  33FC 0000 0000804A               235  			MOVE.W #0,END_B * Altrimenti, resetta le variabili di conteggio il valore degli end e controlla solo se C sia sospeso
000089C0  33FC 0000 0000804C               236  			MOVE.W #0,END_C
000089C8  33FC 0000 00008048               237  			MOVE.W #0,CTR_MEX_B 
000089D0  6000 0012                        238  			BRA IC_RN_BS 	* Salta al controllo della sospensione
000089D4  6000 0130                        239  			BRA IC_REG_REST 	* Il codice non dovrebbe mai arrivare qui,
000089D8                                   240  
000089D8                                   241  ****** Casistica in cui non stava leggendo nessuno
000089D8  0C79 0001 0000804A               242  IC_EX_RN		CMP.W #1,END_B	* Controlla se B non ha terminato i caratteri durante la sua iterazione.
000089E0  6700 0124                        243  		           	BEQ IC_REG_REST
000089E4  1038 2005                        244  IC_RN_BS		MOVE.B PIACA,D0 	* Per prima cosa, si verifica se B � sospeso utilizzando il settimo bit del registro di controllo
000089E8  0200 0080                        245  			ANDI.B  #$80,D0
000089EC  6700 0118                        246  			BEQ  IC_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
000089F0                                   247  			* Altrimenti aggiorna lo stato della variabile di possesso
000089F0  33FC 0000 00008042               248  			MOVE.W #IS_REC_B,POSSESSO * Scrivi chi sta leggendo
000089F8  3039 00008046                    249  			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
000089FE  3200                             250  			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
00008A00  5241                             251  			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
00008A02  33C1 00008046                    252  			MOVE.W D1,TOTAL_CH_RCVD
00008A08  33FC 0001 00008044               253  			MOVE.W #1,CTR_CHAR
00008A10                                   254  			* Lettura del carattere
00008A10  207C 00008000                    255  			MOVEA.L #RCV_BUFFER,A0
00008A16  11B8 2004 0000                   256  			MOVE.B PIADA,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
00008A1C  6000 00E8                        257  			BRA IC_REG_REST
00008A20                                   258  
00008A20                                   259  ****** Casistica in cui stava leggendo altra periferica
00008A20                                   260  			* Qui non � necessario verificare che END_B sia uguale ad 1 ( possesso = is_reading_B, quindi sicuramente END_B � diverso da 1)
00008A20  1038 2005                        261  IC_EX_RB		MOVE.B PIACA,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
00008A24  0200 0080                        262  			ANDI.B  #$80,D0
00008A28  6700 00DC                        263  			BEQ  IC_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
00008A2C  3039 00008046                    264  			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
00008A32  3200                             265  			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
00008A34  5241                             266  			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
00008A36  33C1 00008046                    267  			MOVE.W D1,TOTAL_CH_RCVD
00008A3C  3239 00008044                    268  			MOVE.W CTR_CHAR,D1 * Qui aggiorno il contatore dei caratteri correnti, nota che dato che il possesso non era is_rec_B allora avrei potuto direttamente inserire #1 in ctr_char
00008A42  5241                             269  			ADDI.W #1,D1 
00008A44  33C1 00008044                    270  			MOVE.W D1,CTR_CHAR
00008A4A                                   271  			**** IMPORTANTE: Differentemente dal caso 2: qui � necessario svolgere tutte le operazioni che B avrebbe svolto, non � possibile infatti fare assunzioni sul numero di messaggi gi� ricevuti
00008A4A  B27C 0003                        272  			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
00008A4E  6600 00AA                        273  			BNE IC_RB_END		* Se non � completo allora si legge il carattere di B e si esce
00008A52  33FC 0000 00008044               274  			MOVE.W #0,CTR_CHAR 	* Se il messaggio � completo bisogna sempre resettare il numero di caratteri ricevuti.
00008A5A  33FC FFFF 00008042               275  			MOVE.W #IS_REC_NONE,POSSESSO * In ogni caso si resetta la variabile possesso
00008A62                                   276  			* ATTENZIONE: Differentemente dal caso precedente, B riceve 2 messaggi in una iterazione, quindi si deve incrementare il numero di messaggi ( prima, in IB_EX_RC bastava completare un messaggio di C per andare a controllare end_B).
00008A62  3439 00008048                    277  			MOVE.W CTR_MEX_B,D2
00008A68  5242                             278  			ADDI.W #1,D2
00008A6A  33C2 00008048                    279  			MOVE.W D2,CTR_MEX_B
00008A70  B47C 0002                        280  			CMP.W #N_MEX_B_ITER,D2 	* Se B non ha concluso, ossia il numero dei suoi messaggi � 2
00008A74  6600 0048                        281  			BNE IC_RC_UP_IT 		* Anche se B non ha raggiunto i due messaggi, devo recuperare il messaggio di C in questa ISR ( solo se end_C != 1).
00008A78  33FC 0001 0000804A               282  			MOVE.W #1,END_B	
00008A80  0C79 0001 0000804C               283  			CMP.W #1,END_C 		* Controlla se anche C ha concluso l'iterazione
00008A88  6600 0034                        284  			BNE IC_RC_UP_IT		* Se non ha concluso allora salta.	
00008A8C  3239 0000804E                    285  			MOVE.W K,D1			* Se invece anche C ha concluso bisogna aggiornare il contatore
00008A92  5241                             286  			ADDI.W   #1,D1
00008A94  33C1 0000804E                    287  			MOVE.W D1,K
00008A9A  0C79 0005 0000804E               288  			CMP.W  #N_ITER,K
00008AA2  6700 0056                        289  			BEQ   IC_RB_END * Se ho raggiunto il numero massimo di iterazioni allora esco leggendo l'ultimo carattere
00008AA6                                   290  			* Altrimenti resetta le variabili, leggi il carattere di B e poi leggi il carattere che C avrebbe dovuto ricevere
00008AA6  33FC 0000 0000804A               291  			MOVE.W #0,END_B
00008AAE  33FC 0000 0000804C               292  			MOVE.W #0,END_C
00008AB6  33FC 0000 00008048               293  			MOVE.W #0,CTR_MEX_B
00008ABE  0C79 0001 0000804C               294  IC_RC_UP_IT		CMP.W #1,END_C	* Differentemente dal caso precedente, � possibile arrivare qui nel caso in cui n_mex_B = 1 (<2) ma con end_C = 1
00008AC6  6700 0032                        295  			BEQ IC_RB_END	* In questa casistica salto.
00008ACA  33FC 0001 00008042               296  			MOVE.W #IS_REC_C,POSSESSO
00008AD2  3239 00008046                    297  			MOVE.W TOTAL_CH_RCVD,D1
00008AD8  3439 00008044                    298  			MOVE.W CTR_CHAR,D2
00008ADE  207C 00008000                    299  			MOVEA.L #RCV_BUFFER,A0
00008AE4  11B8 2008 1000                   300  			MOVE.B  PIADA2,(A0,D1)
00008AEA  5242                             301  			ADDI.W #1,D2
00008AEC  33C2 00008044                    302  			MOVE.W D2,CTR_CHAR
00008AF2  5241                             303  			ADDI.W #1,D1
00008AF4  33C1 00008046                    304  			MOVE.W D1,TOTAL_CH_RCVD
00008AFA                                   305  
00008AFA                                   306  			* Come nel caso precedente, la lettura avviene alla fine dopo aggiornamento delle variabili di stato.
00008AFA  207C 00008000                    307  IC_RB_END		MOVEA.L #RCV_BUFFER,A0
00008B00  11B8 2004 0000                   308  			MOVE.B PIADA,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
00008B06                                   309  
00008B06                                   310  			
00008B06  4CDF 0107                        311  IC_REG_REST		MOVEM.L (SP)+,D0-D2/A0
00008B0A  4E73                             312  IC_RTE      		RTE
00008B0C                                   313  			END INIT

No errors detected
No warnings generated
