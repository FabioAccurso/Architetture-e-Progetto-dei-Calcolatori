   ORG $8000

***************  Definizione di macro
IS_REC_C   EQU 1     *  Valore della variabile Possesso quando si sta ricevendo da C
IS_REC_B   EQU 0     *  Valore della variabile Possesso quando si sta ricevendo da B 
IS_REC_NONE EQU -1 * Valore della variabile di possesso quando non si sta ricevendo da nessuno

MEX_CHAR	EQU 3     *  Numero di caratteri che compongono un messaggio
N_ITER	EQU 5	   *  Numero di iterazioni di esecuzione 
N_MEX_B_ITER  EQU 2 * Numero di messaggi attesi da B in una iterazione (un messaggio � composto da MEX_CHAR caratteri)
N_MEX_PER_ITER EQU 3 * Numero di messaggi per iterazione

* Registri di controllo della PIA.
PIADA	EQU    $2004	
PIACA	EQU    $2005	
PIADA2	EQU	$2008
PIACA2	EQU	$2009

***************** Definizioni di variabili
RCV_BUFFER 		DS.B  64  		* La dimensione del messaggio viene data dal prodotto di  Numero It* Numero Mex per It * Caratteri per messaggio ( 3 * 3 * 3 = 27) 
LOCK            		DC.W 0 		* Variabile utilizzata per l'accesso alla sezione critica mediante TAS
POSSESSO  		DC.W IS_REC_NONE  * Variabile ternaria che indica il dispositivo da cui si sta attualmente ricevendo
CTR_CHAR   		DC.W 0	* Contatore di caratteri ricevuti da una periferica, utilizzato per verificare la completezza di un messaggio
TOTAL_CH_RCVD 	DC.W 0	* Contatore del numero totale di bytes ricevuti.
CTR_MEX_B 		DC.W 0 	* Contatore dei messaggi ricevuti da B durante una iterazione
END_B         		DC.W 0	* Variabile che indica che il sistema da B ha terminato la ricezione dei messaggi in una iterazione. 
END_C         		DC.W 0       	* Variabile che indica che il sistema da C ha terminato la ricezione dei messaggi in una iterazione.
K                  		DC.W 0       	* Contatore delle iterazioni.



	ORG	$8200

INIT	JSR	INIZIALIZZA

	MOVE.W	SR,D1
	ANDI.W	#$D8FF,D1
	MOVE.W	D1,SR


LOOP		MOVE.W END_B,D5
		MOVE.W END_C,D6
		MOVE.W K,D7
		MOVE.W POSSESSO,D4
		JMP	LOOP



INIZIALIZZA
	MOVE.B	#0,PIACA
	MOVE.B	#0,PIADA
	MOVE.B	#%00100101,PIACA
	MOVE.B	#0,PIACA2
	MOVE.B	#0,PIADA2
	MOVE.B	#%00100101,PIACA2
	RTS

     ORG $8700
******** Inizio ISR con sezione critica.
IB     	 		TAS LOCK 		* Per prima cosa prova ad ottenere il lock
	 		BNE IB_RTE		* Se non lo si ottiene si esce
	 		CMP.W #1,END_B 	* Se C ha terminato rilascia il lock senza aggiornare la variabile di possesso
	 		BEQ IB_REL_LOCK	
IB_CK_OWN		CMP.W  #IS_REC_C,POSSESSO * Se possesso = is_reading_C allora rilascia il lock, senza aggiornare la variabile di possesso
	     		BEQ IB_REL_LOCK
******* Fine della sezione critica
			MOVE.W #IS_REC_B,POSSESSO * Da questo momento in poi la ricezione avviene da B
IB_REL_LOCK		MOVE.W #0,LOCK * Posso rilasciare il Lock

********  Controllo per lo switch case
			* A questo punto bisogna distinguere le differenti casistiche a seconda del valore della variabile possesso.
			* Qui eseguo il salvataggio del contesto
			MOVEM.L D0-D2/A0,-(SP)
			
			CMP.W #IS_REC_NONE,POSSESSO
			BEQ IB_EX_RN * I vari casi sono indicati come ISRB_ Execution_Receiving"Type", in questo caso RN perch� possesso � "is_rec_none"
			CMP.W  #IS_REC_C,POSSESSO
			BEQ IB_EX_RC

****** Casistica in cui la ISR deve leggere il messaggio in quanto � suo il possesso.	
IB_EX_RB		MOVE.W TOTAL_CH_RCVD,D0
			MOVE.W CTR_CHAR,D1
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA,(A0,D0) * Salva il carattere
			ADD.W #1,D0                   		* Incrementa di 1 il numero di caratteri TOTALI RICEVUTI
			MOVE.W D0,TOTAL_CH_RCVD	* Aggiorna la var in memoria
			ADD.W #1,D1                   		* Incrementa di 1 il numero di caratteri del messaggio corrente
			MOVE.W D1,CTR_CHAR		* Aggiorna la variabile in memoria
			***  Controlli messaggio completo
			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
			BNE IB_REG_REST		* Se non � completo allora salta alla fine
			MOVE.W #0,CTR_CHAR 	* Se invece il numero di messaggi � completo, resetta il numero di caratteri del messaggio attuale
			MOVE.W #IS_REC_NONE,POSSESSO * La variabile possesso va resettata in quanto B non la possiede pi�.
			MOVE.W CTR_MEX_B,D1	* Salva il conteggio attuale dei messaggi ricevuti da B (durante una iterazione)
			ADDI.W  #1,D1		
			MOVE.W D1,CTR_MEX_B	* Incrementa di 1 il numero di messaggi ricevuti da B nell'iterazione corrente
			CMP.W  #N_MEX_B_PER_ITER,D1 *Verifica se B non abbia completato il numero di messaggi da ricevere in una iterazione
			BNE	  IB_EX_RN * Se non li ha completati, rimane solo da verificare se C ha un messaggio sospeso e pu� leggere, questo coincide con la casistica IB_EX_RN
			* Se invece li ha completati, allora si aggiorna END_B e si verifica che anche C non abbia finito
			MOVE.W #1,END_B
			CMP.W #1,END_C * Controllo se end_C == 1
			BNE IB_RN_CS * Anche in questo caso, se non sono uguali, allora salto alla verifica di C (non � necessario verificare che END_C sia diverso da 1, quindi salto alla label immediatamente successiva)
			* Verifico che END_B ed END_C siano identici.
			MOVE.W K,D2
			ADDI.W #1,D2
			MOVE.W D2,K * Incrementa il numero di iterazioni
			CMP.W #N_ITER,D2 * Se � uguale allora salta alla fine( lasciando end_B ed end_C pari ad 1)
			BEQ IB_REG_REST
			MOVE.W #0,END_B * Altrimenti, resetta le variabili di conteggio il valore degli end e controlla solo se C sia sospeso
			MOVE.W #0,END_C
			MOVE.W #0,CTR_MEX_B 
			BRA IB_RN_CS 	* Salta al controllo della sospensione
			BRA IB_REG_REST * Il codice non dovrebbe mai arrivare qui,

****** Casistica in cui non stava leggendo nessuno
IB_EX_RN		CMP.W #1,END_C	* Controlla se C non ha terminato i caratteri durante la sua iterazione.
		           	BEQ IB_REG_REST
* Nota: 	IB_Receiving None, Check Suspended ( � una sottolabel di IB_EX_RN)
* 		Questa sottolabel � definita per convenienza, in quanto molti sottobranch terminano con un controllo dello stato di sospesione di C.
IB_RN_CS		MOVE.B PIACA2,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
			ANDI.B  #$80,D0
			BEQ  IB_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
			* Altrimenti aggiorna lo stato della variabile di possesso
			MOVE.W #IS_REC_C,POSSESSO * Scrivi chi sta leggendo
			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
			MOVE.W D1,TOTAL_CH_RCVD
			* Quello che stiamo ricevendo � SICURAMENTE il primo carattere di C, quindi, invece di incrementare, andiamo direttamente a scrivere uno in memoria.
			MOVE.W #1,CTR_CHAR
			* Lettura del carattere
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA2,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
			BRA IB_REG_REST

****** Casistica in cui stava leggendo altra periferica
			* Qui non � necessario verificare che END_C sia uguale ad 1 ( possesso = is_reading_C, quindi sicuramente END_C � diverso da 1)
IB_EX_RC		MOVE.B PIACA2,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
			ANDI.B  #$80,D0
			BEQ  IB_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
			MOVE.W D1,TOTAL_CH_RCVD
			MOVE.W CTR_CHAR,D1 * Qui aggiorno il contatore dei caratteri correnti, nota che dato che il possesso non era is_rec_C allora avrei potuto direttamente inserire #1 in ctr_char
			ADDI.W #1,D1 
			MOVE.W D1,CTR_CHAR
			**** IMPORTANTE: Differentemente dal caso 2: qui � necessario svolgere tutte le operazioni che C avrebbe svolto, non � possibile infatti fare assunzioni sul numero di messaggi gi� ricevuti
			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
			BNE IB_RC_END		* Se non � completo allora si legge il carattere di C e si esce
			MOVE.W #1,END_C 		* Se invece il messaggio � completo, si pone END_C ad 1
			* In ogni caso si resetta la variabile possesso
			MOVE.W #IS_REC_NONE,POSSESSO
			MOVE.W #0,CTR_CHAR * Si resetta il numero di caratteri correnti
			* Si verifica se anche B ha finito	
			CMP.W #1,END_B
			* in Questo caso, se B non ha terminato, procedo  a leggere il carattere di B (e poi seguentemente quello di C).
			BNE IB_RC_UP_IT
			MOVE.W K,D1
			ADDI.W   #1,D1
			MOVE.W D1,K
			CMP.W  #N_ITER,K
			BEQ   IB_RC_END * Se ho raggiunto il numero massimo di iterazioni allora esco ( leggendo prima il carattere di C sempre)
			* Altrimenti resetta le variabili, leggi il carattere di B e poi leggi il carattere che C avrebbe dovuto ricevere
			MOVE.W #0,END_B
			MOVE.W #0,END_C
			MOVE.W #0,CTR_MEX_B

IB_RC_UP_IT		MOVE.W #IS_REC_B,POSSESSO
			MOVE.W TOTAL_CH_RCVD,D1
			MOVE.W CTR_CHAR,D2
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B  PIADA,(A0,D1)
			ADDI.W #1,D2
			MOVE.W D2,CTR_CHAR
			ADDI.W #1,D1
			MOVE.W D1,TOTAL_CH_RCVD

			* Come nel caso precedente, la lettura avviene alla fine dopo aggiornamento delle variabili di stato.
IB_RC_END		MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA2,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato

			
IB_REG_REST		MOVEM.L (SP)+,D0-D2/A0
IB_RTE      		RTE




 		ORG $8900
******** Inizio ISR con sezione critica.
IC     	 		TAS LOCK 		* Per prima cosa prova ad ottenere il lock
	 		BNE IC_RTE		* Se non lo si ottiene si esce
	 		CMP.W #1,END_C 	* Se C ha terminato rilascia il lock senza aggiornare la variabile di possesso
	 		BEQ IC_REL_LOCK	
IC_CK_OWN		CMP.W  #IS_REC_B,POSSESSO * Se possesso = is_reading_B allora rilascia il lock, senza aggiornare la variabile di possesso
	     		BEQ IC_REL_LOCK
******* Fine della sezione critica
			MOVE.W #IS_REC_C,POSSESSO * Da questo momento in poi la ricezione avviene da C
IC_REL_LOCK		MOVE.W #0,LOCK * Posso rilasciare il Lock

******** Controllo per lo switch case
			* A questo punto bisogna distinguere le differenti casistiche a seconda del valore della variabile possesso.
			* Qui eseguo il salvataggio del contesto
			MOVEM.L D0-D2/A0,-(SP)

			* Questa sequenza di CMP simula lo switch case presente nello pseudo-codice.
			CMP.W #IS_REC_NONE,POSSESSO
			BEQ IC_EX_RN 
			CMP.W  #IS_REC_B,POSSESSO
			BEQ IC_EX_RB

****** Casistica in cui la ISR deve leggere il messaggio in quanto � suo il possesso.	
IC_EX_RC		MOVE.W TOTAL_CH_RCVD,D0 	
			MOVE.W CTR_CHAR,D1		
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA2,(A0,D0) * Salva il carattere
			ADDI.W #1,D0                   		* Incrementa di 1 il numero di caratteri TOTALI RICEVUTI
			MOVE.W D0,TOTAL_CH_RCVD	* Aggiorna la var in memoria
			ADDI.W #1,D1                   		* Incrementa di 1 il numero di caratteri del messaggio corrente
			MOVE.W D1,CTR_CHAR		* Aggiorna la variabile in memoria
			***  Controlli messaggio completo
			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
			BNE IC_REG_REST		* Se non � completo allora salta alla fine
			MOVE.W #0,CTR_CHAR 	* Se invece il numero di messaggi � completo, resetta il numero di caratteri del messaggio attuale
			MOVE.W #1,END_C		* Indica che C ha finito
			MOVE.W #IS_REC_NONE,POSSESSO * La variabile possesso va resettata in quanto C non la possiede pi�.
			CMP.W #1,END_B * Controllo se end_B == 1
			BNE IC_RN_BS * Se B non ha concluso ( end_B != 1) allora devo solo recuperare un carattere di B ( senza nuovamente verificare se end_B == 1)
			MOVE.W K,D2 * Altrimenti devo incrementare il numero di iterazioni.
			ADDI.W #1,D2
			MOVE.W D2,K * Incrementa il numero di iterazioni
			CMP.W #N_ITER,D2 * Se � uguale allora salta alla fine( lasciando end_B ed end_C pari ad 1)
			BEQ IC_REG_REST
			MOVE.W #0,END_B * Altrimenti, resetta le variabili di conteggio il valore degli end e controlla solo se C sia sospeso
			MOVE.W #0,END_C
			MOVE.W #0,CTR_MEX_B 
			BRA IC_RN_BS 	* Salta al controllo della sospensione
			BRA IC_REG_REST 	* Il codice non dovrebbe mai arrivare qui,

****** Casistica in cui non stava leggendo nessuno
IC_EX_RN		CMP.W #1,END_B	* Controlla se B non ha terminato i caratteri durante la sua iterazione.
		           	BEQ IC_REG_REST
IC_RN_BS		MOVE.B PIACA,D0 	* Per prima cosa, si verifica se B � sospeso utilizzando il settimo bit del registro di controllo
			ANDI.B  #$80,D0
			BEQ  IC_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
			* Altrimenti aggiorna lo stato della variabile di possesso
			MOVE.W #IS_REC_B,POSSESSO * Scrivi chi sta leggendo
			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
			MOVE.W D1,TOTAL_CH_RCVD
			MOVE.W #1,CTR_CHAR
			* Lettura del carattere
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato
			BRA IC_REG_REST

****** Casistica in cui stava leggendo altra periferica
			* Qui non � necessario verificare che END_B sia uguale ad 1 ( possesso = is_reading_B, quindi sicuramente END_B � diverso da 1)
IC_EX_RB		MOVE.B PIACA,D0 	* Per prima cosa, si verifica se C � sospeso utilizzando il settimo bit del registro di controllo
			ANDI.B  #$80,D0
			BEQ  IC_REG_REST 	* Se il risultato � zero, ossia il settimo bit non � alto, allora salta alla fine 			
			MOVE.W TOTAL_CH_RCVD,D0 *Salva il conteggio attuale dei caratteri ricevuti
			MOVE.W D0,D1 * Qui lo copio, quando si sblocca una periferica � sempre meglio aggiornare prima le variabili di stato e poi sbloccarla ( non si � in grado di dire quando interromper� di nuovo)
			ADDI.W #1,D1 * Incrementa il numero TOTALE di caratteri ricevuti.
			MOVE.W D1,TOTAL_CH_RCVD
			MOVE.W CTR_CHAR,D1 * Qui aggiorno il contatore dei caratteri correnti, nota che dato che il possesso non era is_rec_B allora avrei potuto direttamente inserire #1 in ctr_char
			ADDI.W #1,D1 
			MOVE.W D1,CTR_CHAR
			**** IMPORTANTE: Differentemente dal caso 2: qui � necessario svolgere tutte le operazioni che B avrebbe svolto, non � possibile infatti fare assunzioni sul numero di messaggi gi� ricevuti
			CMP.W #MEX_CHAR,D1	* Controlla se il messaggio � completo
			BNE IC_RB_END		* Se non � completo allora si legge il carattere di B e si esce
			MOVE.W #0,CTR_CHAR 	* Se il messaggio � completo bisogna sempre resettare il numero di caratteri ricevuti.
			MOVE.W #IS_REC_NONE,POSSESSO * In ogni caso si resetta la variabile possesso
			* ATTENZIONE: Differentemente dal caso precedente, B riceve 2 messaggi in una iterazione, quindi si deve incrementare il numero di messaggi ( prima, in IB_EX_RC bastava completare un messaggio di C per andare a controllare end_B).
			MOVE.W CTR_MEX_B,D2
			ADDI.W #1,D2
			MOVE.W D2,CTR_MEX_B
			CMP.W #N_MEX_B_ITER,D2 	* Se B non ha concluso, ossia il numero dei suoi messaggi � 2
			BNE IC_RC_UP_IT 		* Anche se B non ha raggiunto i due messaggi, devo recuperare il messaggio di C in questa ISR ( solo se end_C != 1).
			MOVE.W #1,END_B	
			CMP.W #1,END_C 		* Controlla se anche C ha concluso l'iterazione
			BNE IC_RC_UP_IT		* Se non ha concluso allora salta.	
			MOVE.W K,D1			* Se invece anche C ha concluso bisogna aggiornare il contatore
			ADDI.W   #1,D1
			MOVE.W D1,K
			CMP.W  #N_ITER,K
			BEQ   IC_RB_END * Se ho raggiunto il numero massimo di iterazioni allora esco leggendo l'ultimo carattere
			* Altrimenti resetta le variabili, leggi il carattere di B e poi leggi il carattere che C avrebbe dovuto ricevere
			MOVE.W #0,END_B
			MOVE.W #0,END_C
			MOVE.W #0,CTR_MEX_B
IC_RC_UP_IT		CMP.W #1,END_C	* Differentemente dal caso precedente, � possibile arrivare qui nel caso in cui n_mex_B = 1 (<2) ma con end_C = 1
			BEQ IC_RB_END	* In questa casistica salto.
			MOVE.W #IS_REC_C,POSSESSO
			MOVE.W TOTAL_CH_RCVD,D1
			MOVE.W CTR_CHAR,D2
			MOVEA.L #RCV_BUFFER,A0
			MOVE.B  PIADA2,(A0,D1)
			ADDI.W #1,D2
			MOVE.W D2,CTR_CHAR
			ADDI.W #1,D1
			MOVE.W D1,TOTAL_CH_RCVD

			* Come nel caso precedente, la lettura avviene alla fine dopo aggiornamento delle variabili di stato.
IC_RB_END		MOVEA.L #RCV_BUFFER,A0
			MOVE.B PIADA,(A0,D0) * Utilizzo D0 perch� devo utilizzare il contatore totale di caratteri (TOTAL_CH_RCVD) prima che fosse aggiornato

			
IC_REG_REST		MOVEM.L (SP)+,D0-D2/A0
IC_RTE      		RTE
			END INIT






